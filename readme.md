# Coding Pattern Techniques

## 1. Two Pointers
As the name suggests, the two pointers pattern uses two pointers 
to iterate over an array or list until the conditions of the problem are satisfied. 
This is useful because it allows us to keep track of the values of two different indexes in a single iteration. 
Whenever there’s a requirement to find two data elements in an array that satisfy a certain condition, 
the two pointers pattern should be the first strategy to come to mind.

## 2. Slow and Fast Pointer
Similar to the two pointers pattern, the fast and slow pointers pattern uses two pointers to traverse an iterable data structure at different speeds. It’s usually used to identify distinguishable features of directional data structures, 
such as a linked list or an array.

The pointers can be used to traverse the array or list in either direction, however, one moves faster than the other. Generally, the slow pointer moves forward by a factor of one, and the fast pointer moves by a factor of two in each step. However, the speed can be adjusted according to the problem statement.

## 3. Sliding Window
The sliding window pattern is used to process sequential data by maintaining a moving subset of elements, called a window. 
The pattern is aimed at reducing the use of nested loops in an algorithm. It may be viewed as a variation of the two pointers pattern, with the pointers being used to set the window bounds.

## 4. Merge Intervals

The merge intervals pattern deals with problems involving overlapping intervals. 
Each interval is represented by a start and an end time. For example, an interval of
[10 , 20] seconds means that the interval starts at 10 seconds and ends at 20 seconds, such that both
10 and time 20 are included in the interval.

The most common problems solved using this pattern are scheduling problems.

## 5. In-place Reversal of a Linked List
The in-place reversal of a linked list pattern allows us to reverse a linked list without any additional memory, using only the given nodes.

## 6. Two Heaps

## 7. K-way merge

## 8. Top K Elements

## 9. Modified Binary Search

## 10. Subsets

## 11. Greedy Techniques

## 12. Backtracking

## 13. Dynamic Programming

## 14. Cyclic Sort

## 15. Topological Sort

## 16. Matrices

## 17. Stacks

## 18. Graphs

## 19. Tree Depth First Search

## 20. Tree Breadth First Search

## 21. Trie

## 22. Hash Maps

## 23. Knowing What to Track

## 24. Union Find
